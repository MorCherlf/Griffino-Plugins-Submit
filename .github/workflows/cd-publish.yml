name: Plugin Publish CD

on:
  push:
    branches: [main]
    paths:
      - 'submissions/**'

jobs:
  publish:
    name: Build and Publish Plugin
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      actions: write    # 用于删除 Artifact

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Find merged submission
        id: find
        run: |
          CHANGED=$(git diff --name-only HEAD~1 HEAD \
            | grep '^submissions/' | grep -v '^submissions/\.example' | head -1)
          if [ -z "$CHANGED" ]; then
            echo "No submission changes detected. Skipping."
            exit 0
          fi
          PLUGIN_DIR=$(echo "$CHANGED" | cut -d'/' -f1-2)
          PLUGIN_ID=$(echo "$PLUGIN_DIR" | cut -d'/' -f2)
          echo "plugin_dir=$PLUGIN_DIR" >> $GITHUB_OUTPUT
          echo "plugin_id=$PLUGIN_ID" >> $GITHUB_OUTPUT

      - name: Read submission metadata
        if: steps.find.outputs.plugin_dir != ''
        id: meta
        run: |
          python3 - <<EOF
          import json, os
          with open("${{ steps.find.outputs.plugin_dir }}/submission.json") as f:
              s = json.load(f)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"version={s['version']}\n")
              f.write(f"source_repo={s['sourceRepo']}\n")
              f.write(f"source_commit={s['sourceCommit']}\n")
              f.write(f"changelog={s['changelog']}\n")
          EOF

      - name: Find PR number for this merge
        if: steps.find.outputs.plugin_dir != ''
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const commit = context.sha;
            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commit,
            });
            if (prs.data.length === 0) {
              core.setFailed('No PR found associated with this merge commit.');
              return;
            }
            const pr = prs.data[0];
            core.setOutput('number', pr.number);
            console.log(`Found PR #${pr.number}`);

      - name: Download amd64 artifact
        if: steps.find.outputs.plugin_dir != ''
        uses: actions/download-artifact@v4
        with:
          name: image-amd64-pr${{ steps.pr.outputs.number }}
          path: /tmp/artifacts
          github-token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          run-id: latest

      - name: Download arm64 artifact
        if: steps.find.outputs.plugin_dir != ''
        uses: actions/download-artifact@v4
        with:
          name: image-arm64-pr${{ steps.pr.outputs.number }}
          path: /tmp/artifacts
          github-token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          run-id: latest

      - name: Load images and create multi-arch manifest
        if: steps.find.outputs.plugin_dir != ''
        run: |
          PLUGIN_ID="${{ steps.find.outputs.plugin_id }}"
          VERSION="${{ steps.meta.outputs.version }}"

          docker load < /tmp/artifacts/image-amd64.tar.gz
          docker load < /tmp/artifacts/image-arm64.tar.gz

          # Re-tag with final names before pushing
          docker tag griffino-ci/${PLUGIN_ID}:${VERSION}-amd64 \
            ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}-amd64
          docker tag griffino-ci/${PLUGIN_ID}:${VERSION}-arm64 \
            ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}-arm64

      - name: Login to GitHub Container Registry
        if: steps.find.outputs.plugin_dir != ''
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: GriffinoBot
          password: ${{ secrets.GRIFFINO_BOT_CD_TOKEN }}

      - name: Push images and create manifest
        if: steps.find.outputs.plugin_dir != ''
        run: |
          PLUGIN_ID="${{ steps.find.outputs.plugin_id }}"
          VERSION="${{ steps.meta.outputs.version }}"
          SOURCE_COMMIT="${{ steps.meta.outputs.source_commit }}"
          SOURCE_REPO="${{ steps.meta.outputs.source_repo }}"

          docker push ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}-amd64
          docker push ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}-arm64

          docker buildx imagetools create \
            --tag ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION} \
            --tag ghcr.io/griffinguard/${PLUGIN_ID}:latest \
            --annotation "index:org.opencontainers.image.source=${SOURCE_REPO}" \
            --annotation "index:org.opencontainers.image.revision=${SOURCE_COMMIT}" \
            --annotation "index:griffino.plugin.id=${PLUGIN_ID}" \
            --annotation "index:griffino.plugin.version=${VERSION}" \
            ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}-amd64 \
            ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}-arm64

          echo "✅ Multi-arch manifest created for ${PLUGIN_ID}:${VERSION}"

      - name: Update approved-images.json if new images were introduced
        if: steps.find.outputs.plugin_dir != ''
        run: |
          pip install pyyaml --quiet
          curl -sf https://raw.githubusercontent.com/GriffinGuard/griffino-plugins/main/approved-images.json \
            -o approved-images.json

          PLUGIN_DIR="${{ steps.find.outputs.plugin_dir }}"
          PLUGIN_ID="${{ steps.find.outputs.plugin_id }}"

          PLUGIN_DIR_PY="${PLUGIN_DIR}" PLUGIN_ID_PY="${PLUGIN_ID}" python3 - <<'PYEOF'
          import json, yaml, os
          from datetime import datetime, timezone

          plugin_dir = os.environ["PLUGIN_DIR_PY"]
          plugin_id  = os.environ["PLUGIN_ID_PY"]

          with open("approved-images.json") as f:
              approved_data = json.load(f)
          approved_set = {img["image"] for img in approved_data["approvedImages"]}

          with open(f"{plugin_dir}/plugin.boot.yml") as f:
              boot = yaml.safe_load(f)

          main_svc = boot.get("mainServiceId", "")
          new_images = []
          for svc_id, svc in boot.get("services", {}).items():
              if svc_id == main_svc:
                  continue
              image = svc.get("image", "")
              if image.startswith("ghcr.io/griffinguard/"):
                  continue
              if image and image not in approved_set:
                  new_images.append({
                      "image": image,
                      "approvedAt": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
                      "approvedBy": "GriffinoBot",
                      "notes": f"Approved via plugin submission: {plugin_id}"
                  })

          if new_images:
              approved_data["approvedImages"].extend(new_images)
              approved_data["updatedAt"] = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
              with open("approved-images.json", "w") as f:
                  json.dump(approved_data, f, indent=2, ensure_ascii=False)
              print(f"Added {len(new_images)} new image(s) to whitelist.")
          else:
              print("No new images to add to whitelist.")
          PYEOF

      - name: Rewrite main service image in plugin.boot.yml
        if: steps.find.outputs.plugin_dir != ''
        run: |
          pip install pyyaml --quiet
          PLUGIN_DIR="${{ steps.find.outputs.plugin_dir }}"
          PLUGIN_ID="${{ steps.find.outputs.plugin_id }}"
          VERSION="${{ steps.meta.outputs.version }}"
          IMAGE="ghcr.io/griffinguard/${PLUGIN_ID}:${VERSION}"
          BOOT_FILE="${PLUGIN_DIR}/plugin.boot.yml"

          BOOT_FILE_PY="${BOOT_FILE}" IMAGE_PY="${IMAGE}" python3 - <<'PYEOF'
          import yaml, os

          boot_file = os.environ["BOOT_FILE_PY"]
          image     = os.environ["IMAGE_PY"]

          with open(boot_file) as f:
              boot = yaml.safe_load(f)

          main_svc = boot.get("mainServiceId")
          if main_svc and main_svc in boot.get("services", {}):
              boot["services"][main_svc]["image"] = image

          with open(boot_file, "w") as f:
              yaml.dump(boot, f, allow_unicode=True, sort_keys=False)

          print(f"Rewrote main service image to: {image}")
          PYEOF

      - name: Import GPG key
        if: steps.find.outputs.plugin_dir != ''
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

      - name: Publish to griffino-plugins
        if: steps.find.outputs.plugin_dir != ''
        env:
          CD_BOT_TOKEN: ${{ secrets.CD_BOT_TOKEN }}
        run: |
          PLUGIN_ID="${{ steps.find.outputs.plugin_id }}"
          VERSION="${{ steps.meta.outputs.version }}"

          git clone https://x-access-token:${CD_BOT_TOKEN}@github.com/GriffinGuard/griffino-plugins.git publish-target
          cd publish-target

          git config user.name "GriffinoBot"
          git config user.email "cd-bot@griffino.cc"
          git config user.signingkey ${{ secrets.GPG_KEY_ID }}
          git config commit.gpgsign true

          mkdir -p plugins/${PLUGIN_ID}/${VERSION}
          cp -r ../${{ steps.find.outputs.plugin_dir }}/. plugins/${PLUGIN_ID}/${VERSION}/
          rm -f plugins/${PLUGIN_ID}/latest
          ln -sf ${VERSION} plugins/${PLUGIN_ID}/latest
          cp ../approved-images.json approved-images.json

          PLUGIN_ID_PY="${PLUGIN_ID}" VERSION_PY="${VERSION}" \
          CHANGELOG_PY="${{ steps.meta.outputs.changelog }}" python3 - <<'PYEOF'
          import json, os
          from datetime import datetime, timezone

          PLUGIN_ID = os.environ["PLUGIN_ID_PY"]
          VERSION   = os.environ["VERSION_PY"]
          CHANGELOG = os.environ["CHANGELOG_PY"]

          with open("registry.json") as f:
              registry = json.load(f)

          plugin_entry = next((p for p in registry["plugins"] if p["id"] == PLUGIN_ID), None)

          new_version = {
              "version": VERSION,
              "manifestPath": f"plugins/{PLUGIN_ID}/{VERSION}/plugin.manifest.json",
              "publishedAt": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
              "changelog": CHANGELOG
          }

          if plugin_entry:
              plugin_entry["latestVersion"] = VERSION
              existing = [v for v in plugin_entry["versions"] if v["version"] != VERSION]
              plugin_entry["versions"] = [new_version] + existing
          else:
              with open(f"plugins/{PLUGIN_ID}/{VERSION}/plugin.manifest.json") as f:
                  manifest = json.load(f)
              name = manifest["name"]["default"] if isinstance(manifest["name"], dict) else manifest["name"]
              desc = manifest["description"]["default"] if isinstance(manifest["description"], dict) else manifest["description"]
              registry["plugins"].append({
                  "id": PLUGIN_ID,
                  "name": name,
                  "description": desc,
                  "latestVersion": VERSION,
                  "apiVersion": "1",
                  "author": manifest.get("author", ""),
                  "license": manifest.get("license", ""),
                  "tags": [],
                  "verified": False,
                  "versions": [new_version]
              })

          registry["updatedAt"] = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

          with open("registry.json", "w") as f:
              json.dump(registry, f, indent=2, ensure_ascii=False)

          print(f"registry.json updated for {PLUGIN_ID}@{VERSION}")
          PYEOF

          git add .
          git commit -S -m "chore: publish ${PLUGIN_ID}@${VERSION} [skip ci]"
          git push

      - name: Delete CI artifacts
        if: steps.find.outputs.plugin_dir != ''
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const names = [
              `image-amd64-pr${prNumber}`,
              `image-arm64-pr${prNumber}`
            ];
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            for (const artifact of artifacts.data.artifacts) {
              if (names.includes(artifact.name)) {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
                console.log(`Deleted artifact: ${artifact.name}`);
              }
            }