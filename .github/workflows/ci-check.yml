name: Plugin Submission CI

on:
  pull_request_target:
    paths:
      - 'submissions/**'

jobs:
  validate:
    name: Validate Submission
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Find changed submission directory
        id: find
        run: |
          CHANGED=$(git diff --name-only origin/main...${{ github.event.pull_request.head.sha }} | grep '^submissions/' | grep -v '^submissions/\.example' | head -1)
          if [ -z "$CHANGED" ]; then
            echo "No submission changes detected."
            exit 0
          fi
          PLUGIN_DIR=$(echo "$CHANGED" | cut -d'/' -f1-2)
          PLUGIN_ID=$(echo "$PLUGIN_DIR" | cut -d'/' -f2)
          echo "plugin_dir=$PLUGIN_DIR" >> $GITHUB_OUTPUT
          echo "plugin_id=$PLUGIN_ID" >> $GITHUB_OUTPUT

          if git show origin/main:"$PLUGIN_DIR/submission.json" > /dev/null 2>&1; then
            echo "is_new=false" >> $GITHUB_OUTPUT
          else
            echo "is_new=true" >> $GITHUB_OUTPUT
          fi

      - name: Check required files
        if: steps.find.outputs.plugin_dir != ''
        run: |
          PLUGIN_DIR="${{ steps.find.outputs.plugin_dir }}"
          MISSING=()
          for f in submission.json plugin.manifest.json plugin.boot.yml config.boot.json; do
            if [ ! -f "$PLUGIN_DIR/$f" ]; then
              MISSING+=("$f")
            fi
          done
          if [ ${#MISSING[@]} -ne 0 ]; then
            echo "::error::Missing required files: ${MISSING[*]}"
            exit 1
          fi

      - name: Validate submission.json
        if: steps.find.outputs.plugin_dir != ''
        run: |
          python3 - <<EOF
          import json, sys

          with open("${{ steps.find.outputs.plugin_dir }}/submission.json") as f:
              data = json.load(f)

          required = ["pluginId", "version", "developerGitHub", "sourceRepo", "sourceCommit",
                      "mainServiceDockerfile", "submittedAt", "changelog"]
          missing = [k for k in required if not data.get(k)]
          if missing:
              print(f"::error::submission.json missing required fields: {missing}")
              sys.exit(1)

          if len(data["sourceCommit"]) != 40:
              print("::error::sourceCommit must be a full 40-character commit hash.")
              sys.exit(1)
          EOF

      - name: Validate plugin.manifest.json
        if: steps.find.outputs.plugin_dir != ''
        run: |
          python3 - <<EOF
          import json, sys

          with open("${{ steps.find.outputs.plugin_dir }}/plugin.manifest.json") as f:
              manifest = json.load(f)

          with open("${{ steps.find.outputs.plugin_dir }}/submission.json") as f:
              submission = json.load(f)

          required = ["griffinoPluginManifestVersion", "id", "version", "name", "description",
                      "author", "license", "configurationFiles", "capabilities"]
          missing = [k for k in required if k not in manifest]
          if missing:
              print(f"::error::plugin.manifest.json missing required fields: {missing}")
              sys.exit(1)

          if manifest["id"] != submission["pluginId"]:
              print(f"::error::manifest.id does not match submission.pluginId")
              sys.exit(1)

          if manifest["version"] != submission["version"]:
              print(f"::error::manifest.version does not match submission.version")
              sys.exit(1)

          if not manifest.get("capabilities"):
              print("::error::plugin.manifest.json must declare at least one capability.")
              sys.exit(1)
          EOF

      - name: Fetch approved image whitelist
        if: steps.find.outputs.plugin_dir != ''
        run: |
          curl -sf https://raw.githubusercontent.com/GriffinGuard/griffino-plugins/main/approved-images.json \
            -o approved-images.json

      - name: Check image whitelist
        id: image_check
        if: steps.find.outputs.plugin_dir != ''
        run: |
          pip install pyyaml --quiet
          python3 - <<EOF
          import json, yaml, os

          with open("approved-images.json") as f:
              approved = {img["image"] for img in json.load(f)["approvedImages"]}

          with open("${{ steps.find.outputs.plugin_dir }}/plugin.boot.yml") as f:
              boot = yaml.safe_load(f)

          main_service_id = boot.get("mainServiceId", "")
          unapproved = []
          for svc_id, svc in boot.get("services", {}).items():
              if svc_id == main_service_id:
                  continue
              image = svc.get("image", "")
              if image.startswith("ghcr.io/griffinguard/"):
                  continue
              if image and image not in approved:
                  unapproved.append(image)

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              if unapproved:
                  f.write(f"unapproved_images={','.join(unapproved)}\n")
                  f.write("has_unapproved=true\n")
              else:
                  f.write("has_unapproved=false\n")
          EOF

      - name: Collect metadata
        id: metadata
        if: steps.find.outputs.plugin_dir != ''
        run: |
          python3 - <<EOF
          import json, os, subprocess

          plugin_dir = "${{ steps.find.outputs.plugin_dir }}"
          is_new = "${{ steps.find.outputs.is_new }}" == "true"

          with open(f"{plugin_dir}/submission.json") as f:
              submission = json.load(f)

          with open(f"{plugin_dir}/plugin.manifest.json") as f:
              manifest = json.load(f)

          source_repo   = submission["sourceRepo"]
          source_commit = submission["sourceCommit"]
          version       = submission["version"]
          changelog     = submission["changelog"]
          short_commit  = source_commit[:7]
          commit_url    = f"{source_repo}/commit/{source_commit}"

          name = manifest["name"]
          if isinstance(name, dict):
              name = name.get("default", "")

          # Auxiliary images (non-main-service)
          with open(f"{plugin_dir}/plugin.boot.yml") as f:
              import yaml
              boot = yaml.safe_load(f)

          main_svc = boot.get("mainServiceId", "")
          aux_images = []
          for svc_id, svc in boot.get("services", {}).items():
              if svc_id == main_svc:
                  continue
              img = svc.get("image", "")
              if img:
                  aux_images.append(img)

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"plugin_name={name}\n")
              f.write(f"version={version}\n")
              f.write(f"source_repo={source_repo}\n")
              f.write(f"source_commit={source_commit}\n")
              f.write(f"short_commit={short_commit}\n")
              f.write(f"commit_url={commit_url}\n")
              f.write(f"changelog={changelog}\n")
              f.write(f"aux_images={','.join(aux_images)}\n")

          # Diff for updates
          diff_lines = []
          if not is_new:
              result = subprocess.run(
                  ["git", "show", f"origin/main:{plugin_dir}/plugin.manifest.json"],
                  capture_output=True, text=True
              )
              if result.returncode == 0:
                  old = json.loads(result.stdout)

                  old_ver = old.get("version", "")
                  new_ver = manifest.get("version", "")
                  if old_ver != new_ver:
                      diff_lines.append(f"| Version | `{old_ver}` â†’ `{new_ver}` |")

                  old_caps = {c["id"]: c["type"] for c in old.get("capabilities", [])}
                  new_caps = {c["id"]: c["type"] for c in manifest.get("capabilities", [])}
                  for cap in set(new_caps) - set(old_caps):
                      diff_lines.append(f"| Capability | âž• `{new_caps[cap]}` added |")
                  for cap in set(old_caps) - set(new_caps):
                      diff_lines.append(f"| Capability | âž– `{old_caps[cap]}` removed |")

                  old_perms = {p["name"] for p in old.get("permissionsRequested", [])}
                  new_perms = {p["name"] for p in manifest.get("permissionsRequested", [])}
                  for p in new_perms - old_perms:
                      diff_lines.append(f"| Permission | âž• `{p}` added |")
                  for p in old_perms - new_perms:
                      diff_lines.append(f"| Permission | âž– `{p}` removed |")

                  # Compare submission.json for old commit
                  result2 = subprocess.run(
                      ["git", "show", f"origin/main:{plugin_dir}/submission.json"],
                      capture_output=True, text=True
                  )
                  if result2.returncode == 0:
                      old_sub = json.loads(result2.stdout)
                      old_commit = old_sub.get("sourceCommit", "")[:7]
                      old_repo   = old_sub.get("sourceRepo", "")
                      diff_lines.append(f"| Source | [`{old_commit}`]({old_repo}/commit/{old_sub.get('sourceCommit','')}) â†’ [`{short_commit}`]({commit_url}) |")

          with open("/tmp/diff_lines.txt", "w") as f:
              f.write("\n".join(diff_lines))
          EOF

      - name: Post review comment
        if: steps.find.outputs.plugin_dir != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GRIFFINO_BOT_TOKEN }}
          script: |
            const fs = require('fs');

            const isNew        = '${{ steps.find.outputs.is_new }}' === 'true';
            const pluginId     = '${{ steps.find.outputs.plugin_id }}';
            const pluginName   = '${{ steps.metadata.outputs.plugin_name }}';
            const version      = '${{ steps.metadata.outputs.version }}';
            const sourceRepo   = '${{ steps.metadata.outputs.source_repo }}';
            const sourceCommit = '${{ steps.metadata.outputs.source_commit }}';
            const shortCommit  = '${{ steps.metadata.outputs.short_commit }}';
            const commitUrl    = '${{ steps.metadata.outputs.commit_url }}';
            const changelog    = '${{ steps.metadata.outputs.changelog }}';
            const hasUnapproved = '${{ steps.image_check.outputs.has_unapproved }}' === 'true';
            const unapprovedRaw = '${{ steps.image_check.outputs.unapproved_images }}';
            const unapprovedImages = hasUnapproved ? unapprovedRaw.split(',') : [];
            const auxImagesRaw = '${{ steps.metadata.outputs.aux_images }}';
            const auxImages = auxImagesRaw ? auxImagesRaw.split(',') : [];

            let diffLines = [];
            try {
              const raw = fs.readFileSync('/tmp/diff_lines.txt', 'utf8').trim();
              if (raw) diffLines = raw.split('\n');
            } catch {}

            // Header
            const allOk = !hasUnapproved;
            let body = allOk
              ? `### âœ… All checks passed!\n\n`
              : `### âš ï¸ Review required\n\n`;

            body += `> Please review this submission carefully before approving. `
            body += `Ensure the source commit matches the declared functionality.\n\n`;

            // Main table
            const typeLabel = isNew ? 'ðŸ†• New Plugin' : 'ðŸ”„ Update';
            const diffText  = !isNew && diffLines.length > 0
              ? ` â€” [Diff](#changes)`
              : (isNew ? '' : ' â€” No manifest changes');

            body += `| Name | Commit | Status |\n|---|---|---|\n`;
            body += `| ${typeLabel} **${pluginName}** | `;
            body += `[\`${shortCommit}\`](${commitUrl}) | `;
            body += `\`${version}\`${diffText} |\n\n`;

            body += `**Changelog:** ${changelog}\n\n`;

            // Auxiliary images section
            if (auxImages.length > 0) {
              const allReviewed = !hasUnapproved;
              body += `#### Auxiliary Images`;
              body += allReviewed
                ? ` (âœ… All approved)\n\n`
                : ` (âš ï¸ ${unapprovedImages.length} pending review)\n\n`;
              body += `| Image | Status |\n|---|---|\n`;
              for (const img of auxImages) {
                const approved = !unapprovedImages.includes(img);
                body += `| \`${img}\` | ${approved ? 'âœ… Approved' : 'âš ï¸ **Not on whitelist**'} |\n`;
              }
              if (hasUnapproved) {
                body += `\n> Unapproved images must be verified before this PR can be merged. `;
                body += `Please check the image source, Dockerfile, and publisher reputation.\n`;
              }
              body += '\n';
            } else {
              body += `#### Auxiliary Images\nNone â€” this plugin has no auxiliary services.\n\n`;
            }

            // Diff section for updates
            if (!isNew && diffLines.length > 0) {
              body += `#### Changes\n\n`;
              body += `| Field | Change |\n|---|---|\n`;
              body += diffLines.join('\n') + '\n\n';
            }

            // Footer
            body += `---\n`;
            body += `<sub>Griffino CI Â· [\`${shortCommit}\`](${commitUrl}) Â· `;
            body += `[Source Repository](${sourceRepo})</sub>`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Summary
        if: steps.find.outputs.plugin_dir != ''
        run: |
          echo "**Plugin:** ${{ steps.find.outputs.plugin_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Is New:** ${{ steps.find.outputs.is_new }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.image_check.outputs.has_unapproved }}" == "true" ]; then
            echo "âš ï¸ Unapproved auxiliary images detected." >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… All checks passed." >> $GITHUB_STEP_SUMMARY
          fi
